<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>email_to_coauthors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="email_to_coauthors_files/libs/clipboard/clipboard.min.js"></script>
<script src="email_to_coauthors_files/libs/quarto-html/quarto.js"></script>
<script src="email_to_coauthors_files/libs/quarto-html/popper.min.js"></script>
<script src="email_to_coauthors_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="email_to_coauthors_files/libs/quarto-html/anchor.min.js"></script>
<link href="email_to_coauthors_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="email_to_coauthors_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="email_to_coauthors_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="email_to_coauthors_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="email_to_coauthors_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="email-to-coauthors---pilot-results-and-next-steps" class="level1">
<h1>Email to Coauthors - Pilot Results and Next Steps</h1>
<p><strong>Subject:</strong> Pilot Results: AI Chatbots Reduce Political Misperceptions + Proposal for Replication with Controls</p>
<hr>
<p>Dear Noah, Olivier, and Stefano,</p>
<p>I’m excited to share results from our pilot study on AI-mediated learning about political outgroups. The findings are promising and suggest a clear path forward for a full replication with proper controls.</p>
<section id="what-we-did" class="level2">
<h2 class="anchored" data-anchor-id="what-we-did">What We Did</h2>
<p>We recruited 500 partisan participants (prescreened to exclude moderates) via Qualtrics panels. Participants: 1. Reported their own environmental attitudes and estimated those of both Democrats and Republicans 2. Engaged in a 10-minute conversation with an AI chatbot (Claude Sonnet 3.5) prompted to represent their political outgroup 3. Re-estimated outgroup environmental attitudes and re-rated outgroup warmth</p>
<p>We measured two primary outcomes: belief accuracy (inverse absolute error) and outgroup warmth (0-100 feeling thermometer).</p>
</section>
<section id="key-findings" class="level2">
<h2 class="anchored" data-anchor-id="key-findings">Key Findings</h2>
<ol type="1">
<li><p><strong>Partisans systematically misperceive each other at baseline.</strong> Democrats rated themselves higher in environmental concern (<em>M</em> = X.XX) than Republicans (<em>M</em> = X.XX), <em>d</em> = X.XX. While participants accurately perceived their ingroups, they dramatically underestimated how environmentally friendly their opponents actually were. Democrats showed significantly greater bias about Republicans than vice versa.</p></li>
<li><p><strong>AI chatbot interactions significantly improved both accuracy and warmth.</strong> Overall, participants became substantially more accurate (<em>d</em> = X.XX, <em>p</em> &lt; .001) and warmer toward the outgroup (<em>d</em> = X.XX, <em>p</em> &lt; .001) after the 10-minute conversation.</p></li>
<li><p><strong>Effects were asymmetric across partisan groups.</strong> Democrats learning about Republicans improved dramatically in accuracy, while Republicans learning about Democrats showed smaller improvements (significant time × party interaction). However, both groups increased warmth at similar rates.</p></li>
<li><p><strong>Political extremism predicted baseline bias but not intervention effectiveness.</strong> More extreme partisans started with worse accuracy and lower warmth, but they benefited equally from the intervention (no moderation by extremism).</p></li>
<li><p><strong>Bot informativeness drove outcomes, not perceived empathy.</strong> Participants who rated the chatbot as more informative showed significantly better accuracy improvement (<em>b</em> = X.XX, <em>p</em> &lt; .05) and greater warmth increases (<em>b</em> = X.XX, <em>p</em> &lt; .05). Perceived empathy did not predict either outcome.</p></li>
<li><p><strong>Engagement showed mixed effects.</strong> Turn count and word count showed weak and inconsistent associations with outcomes. Democrats who wrote more showed better accuracy gains, but this pattern didn’t hold for Republicans or for warmth outcomes.</p></li>
<li><p><strong>Accuracy and warmth gains were correlated for Democrats but not Republicans.</strong> Democrats who became more accurate also became warmer (<em>r</em> = X.XX, <em>p</em> &lt; .001), but this relationship was absent for Republicans (<em>r</em> = X.XX, <em>p</em> = ns).</p></li>
<li><p><strong>Confidence patterns revealed Dunning-Kruger effects at baseline.</strong> Less accurate Democrats were overconfident about their outgroup judgments. After the intervention, more accurate participants gained confidence while less accurate ones did not.</p></li>
</ol>
</section>
<section id="limitations-of-current-pilot" class="level2">
<h2 class="anchored" data-anchor-id="limitations-of-current-pilot">Limitations of Current Pilot</h2>
<p>The pilot has one critical limitation: <strong>no control condition</strong>. We cannot determine whether: - Effects are specific to AI chatbots vs.&nbsp;any form of information exposure - The AI interaction offers advantages over cheaper/simpler alternatives - Effects are due to active engagement vs.&nbsp;passive information reception</p>
<p>Without controls, we cannot make strong claims about causality or relative effectiveness.</p>
</section>
<section id="proposed-next-steps-replication-with-control-conditions" class="level2">
<h2 class="anchored" data-anchor-id="proposed-next-steps-replication-with-control-conditions">Proposed Next Steps: Replication with Control Conditions</h2>
<p>I propose we run a full replication (target N = 600-800) with four conditions, as we discussed with Stefano:</p>
<p><strong>1. Passive Control</strong> - Participants complete pre and post measures with no intervention - Establishes test-retest effects and natural belief change</p>
<p><strong>2. Google Search</strong> - Participants spend 10 minutes searching Google for information about outgroup environmental attitudes - Tests whether simple information seeking produces similar effects - Low cost, highly scalable alternative</p>
<p><strong>3. Perspective-Taking Intervention</strong> - Following Wang et al.&nbsp;(2014, PLOS ONE): Participants imagine “a day in the life” of an outgroup member, actively imagining the world from their perspective—“walking through the world in his shoes” - Classic psychological intervention; tests whether generic perspective-taking matches AI effects - Citation: Wang CS, Kenneth T, Ku G, Galinsky AD (2014) Perspective-Taking Increases Willingness to Engage in Intergroup Contact. PLoS ONE 9(1): e85681. https://doi.org/10.1371/journal.pone.0085681</p>
<p><strong>4. AI Chatbot (Replication)</strong> - Same as pilot: 10-minute conversation with AI representing outgroup - Direct replication to confirm effects</p>
<p>This design would allow us to: - Establish causal effects (vs.&nbsp;passive control) - Test relative effectiveness (AI vs.&nbsp;Google vs.&nbsp;perspective-taking) - Make stronger claims about when/why AI chatbots work - Address cost-benefit questions (is the AI worth it vs.&nbsp;simpler alternatives?)</p>
</section>
<section id="timeline-and-logistics" class="level2">
<h2 class="anchored" data-anchor-id="timeline-and-logistics">Timeline and Logistics</h2>
<p>If we move forward, I propose: - Finalize design and pre-registration: 2 weeks - Data collection: 2-3 weeks - Analysis and writing: 4 weeks - Target submission: Journal of Marketing or JCR</p>
<p>The pilot data and analysis code are fully reproducible and available at [repo link]. I’ve prepared a complete draft manuscript with methods, results, and discussion sections ready for your review.</p>
</section>
<section id="questions-for-discussion" class="level2">
<h2 class="anchored" data-anchor-id="questions-for-discussion">Questions for Discussion</h2>
<ol type="1">
<li>Do the pilot findings justify a full replication?</li>
<li>Are these the right control conditions, or should we modify?</li>
<li>Should we add any additional measures (e.g., behavioral intentions, policy support)?</li>
<li>What’s our target sample size and desired power for between-condition comparisons?</li>
<li>Any concerns about the AI chatbot implementation or measures?</li>
</ol>
<p>I’m happy to schedule a call to discuss next steps, or we can iterate via email. Looking forward to your thoughts!</p>
<p>Best, Ben</p>
<hr>
<p><strong>Attached:</strong> Full pilot manuscript (report.html, report.pdf)</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>